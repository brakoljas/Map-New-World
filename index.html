<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Known Places Map</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position: relative; width: 100vw; height: 100vh; background: #111; overflow: hidden; }

    /* Top-left UI */
    #ui {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      color: #fff;
      z-index: 10;
    }
    button {
      background: rgba(255,255,255,0.10);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.16); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Right panel */
    #panel {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 340px;
      max-height: calc(100vh - 24px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      color: #fff;
      z-index: 10;
    }
    #panelHeader { display: flex; align-items: baseline; justify-content: space-between; gap: 10px; }
    #panelTitle { font-size: 14px; font-weight: 650; opacity: 0.95; }
    #countBadge { font-size: 12px; opacity: 0.8; white-space: nowrap; }

    #controls { display: grid; grid-template-columns: 1fr; gap: 8px; }
    #search {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      color: #fff;
      outline: none;
    }
    #search::placeholder { color: rgba(255,255,255,0.55); }

    #filters {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      align-items: center;
      font-size: 12px;
      opacity: 0.9;
      user-select: none;
    }
    #typeFilter, #sortFilter {
      width: 100%;
      box-sizing: border-box;
      padding: 7px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      color: #fff;
      outline: none;
    }
    option { color: #000; }

    #list {
      overflow: auto;
      padding-right: 4px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      cursor: pointer;
    }
    .item:hover { background: rgba(255,255,255,0.09); }
    .itemName { font-size: 13px; line-height: 1.2; }
    .tag {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      white-space: nowrap;
      opacity: 0.9;
    }

    /* Stage (zoom/pan) */
    #stage {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
      will-change: transform;
      cursor: grab;
    }
    #stage.dragging { cursor: grabbing; }

    #mapImg {
      width: 100vw;
      height: 100vh;
      object-fit: contain;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* Grid overlay */
    #gridCanvas{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0.35;
    }

    #pins { position: absolute; inset: 0; }

    /* Measure overlay */
    #measureSvg{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:visible;
    }

    /* POI pin (28px) */
    .pin {
      position: absolute;
      width: 28px;
      height: 28px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transform: translate(-50%, -50%);
      cursor: pointer;
      pointer-events: auto;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.35));
    }
    .pin.dragging {
      cursor: grabbing;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.55));
    }

    /* Modal (base) */
    .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .modal {
      width: min(560px, calc(100vw - 28px));
      border-radius: 16px;
      background: rgba(15,15,15,0.92);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 20px 60px rgba(0,0,0,0.55);
      color: #fff;
      padding: 14px;
      backdrop-filter: blur(10px);
    }
    .modalHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 4px 4px 10px 4px;
    }
    .modalTitle { font-weight: 650; font-size: 14px; opacity: 0.95; }
    .modalClose {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      padding: 0;
      display: grid;
      place-items: center;
    }
    .modalBody { display: grid; gap: 10px; padding: 4px; }
    .modalFooter {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 10px 4px 4px 4px;
    }

    /* GM editor modal fields */
    #nameInput {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      color: #fff;
      outline: none;
      font-size: 14px;
    }
    #notesInput {
      width: 100%;
      min-height: 90px;
      resize: vertical;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      color: #fff;
      outline: none;
      font-size: 13px;
      line-height: 1.35;
    }

    .typeGrid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
    }
    .typeBtn {
      border-radius: 14px;
      padding: 10px 8px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      display: grid;
      gap: 6px;
      justify-items: center;
      cursor: pointer;
      user-select: none;
    }
    .typeBtn:hover { background: rgba(255,255,255,0.09); }
    .typeBtn.selected {
      border-color: rgba(255,255,255,0.28);
      background: rgba(255,255,255,0.12);
    }
    .typeIcon {
      width: 28px;
      height: 28px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.35));
    }
    .typeLabel {
      font-size: 11px;
      opacity: 0.9;
      text-align: center;
      line-height: 1.1;
    }

    .btnDanger {
      border-color: rgba(255,80,80,0.28);
      background: rgba(255,80,80,0.10);
    }
    .btnDanger:hover { background: rgba(255,80,80,0.16); }

    /* Player view modal */
    #viewTop { display: flex; align-items: center; gap: 10px; }
    #viewIcon {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      display: grid;
      place-items: center;
      flex: 0 0 auto;
    }
    #viewIconInner {
      width: 28px;
      height: 28px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.35));
    }
    #viewName { font-size: 16px; font-weight: 700; line-height: 1.15; }
    #viewTypeTag {
      display: inline-block;
      margin-top: 6px;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      opacity: 0.92;
      width: fit-content;
    }
    #viewNotes { white-space: pre-wrap; line-height: 1.35; font-size: 13px; opacity: 0.95; }
    #viewNotesEmpty { font-size: 13px; opacity: 0.7; font-style: italic; }
  </style>
</head>
<body>
  <div id="wrap">

    <div id="ui">
      <button id="enterGmBtn">Enter GM</button>
      <button id="exitGmBtn" style="display:none;">Exit GM</button>
      <button id="gridBtn" title="Показать/скрыть сетку">Grid</button>
      <button id="measureBtn" title="Измерить расстояние">Measure</button>
      <button id="resetViewBtn" title="Сбросить зум и позицию">Reset view</button>
      <button id="resetBtn" title="Удалить все точки (только в GM)">Reset places</button>
    </div>

    <div id="panel">
      <div id="panelHeader">
        <div id="panelTitle">Известные места</div>
        <div id="countBadge"></div>
      </div>

      <div id="controls">
        <input id="search" type="text" placeholder="Поиск..." />
        <div id="filters">
          <select id="typeFilter" title="Фильтр по типу">
            <option value="all">Все типы</option>
            <option value="settlement">Поселение</option>
            <option value="outpost">Застава</option>
            <option value="ruins">Руины/Храм</option>
            <option value="danger">Опасность</option>
            <option value="resources">Ресурсы</option>
            <option value="unknown">Неизвестно</option>
          </select>
          <select id="sortFilter" title="Сортировка">
            <option value="type_name">Тип → Имя</option>
            <option value="name">Имя</option>
          </select>
        </div>
      </div>

      <div id="list"></div>
    </div>

    <div id="stage">
      <img id="mapImg" src="./assets/map.png" alt="map" />
      <canvas id="gridCanvas"></canvas>
      <div id="pins"></div>
      <svg id="measureSvg"></svg>
    </div>

    <!-- GM Edit Modal -->
    <div id="gmBackdrop" class="backdrop">
      <div class="modal" role="dialog" aria-modal="true">
        <div class="modalHeader">
          <div id="gmModalTitle" class="modalTitle">Новое место</div>
          <button id="gmClose" class="modalClose" title="Закрыть">×</button>
        </div>

        <div class="modalBody">
          <input id="nameInput" type="text" placeholder="Название места" />
          <textarea id="notesInput" placeholder="Заметки (описание, слухи, опасности, лор)"></textarea>
          <div class="typeGrid" id="typeGrid"></div>
        </div>

        <div class="modalFooter">
          <button id="deleteBtn" class="btnDanger" style="display:none;">Удалить</button>
          <button id="gmCancel">Отмена</button>
          <button id="gmSave">Сохранить</button>
        </div>
      </div>
    </div>

    <!-- Player View Modal -->
    <div id="viewBackdrop" class="backdrop">
      <div class="modal" role="dialog" aria-modal="true">
        <div class="modalHeader">
          <div class="modalTitle">Место</div>
          <button id="viewClose" class="modalClose" title="Закрыть">×</button>
        </div>

        <div class="modalBody" style="gap:12px;">
          <div id="viewTop">
            <div id="viewIcon"><div id="viewIconInner"></div></div>
            <div style="display:flex; flex-direction:column; gap:6px;">
              <div id="viewName"></div>
              <div id="viewTypeTag"></div>
            </div>
          </div>

          <div id="viewNotes"></div>
          <div id="viewNotesEmpty" style="display:none;">Нет заметок.</div>
        </div>

        <div class="modalFooter">
          <button id="viewCenterBtn">Центрировать</button>
          <button id="viewOkBtn">Закрыть</button>
        </div>
      </div>
    </div>

  </div>

  <script>
    // ===============================
    // CLOUD CONFIG (Supabase)
    // ===============================
    const CLOUD_ENABLED = true;
    const MAP_ID = "main"; // если сделаешь другую карту — поменяй на другое имя

    const SUPABASE_URL = "https://ezvbphobkkuuzejnatss.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_MPQ6BF4WXk7QG38S_52HnA_qt1FRGYI";

    // ===============================
    // APP CONFIG
    // ===============================
    const GM_PASSWORD = "1272";
    const MIN_SCALE = 0.5;
    const MAX_SCALE = 3.0;
    const ZOOM_SENSITIVITY = 0.0012;

    const GRID_COLS = 100;
    const GRID_ROWS = 69;
    const MILES_PER_CELL = 2;

    // IMPORTANT: make sure these files exist:
    // ./assets/map.png
    // ./assets/poi_settlement.png
    // ./assets/poi_outpost.png
    // ./assets/poi_ruins.png
    // ./assets/poi_danger.png
    // ./assets/poi_resources.png
    // ./assets/poi_unknown.png
    const ICONS = {
      settlement: "./assets/poi_settlement.png",
      outpost: "./assets/poi_outpost.png",
      ruins: "./assets/poi_ruins.png",
      danger: "./assets/poi_danger.png",
      resources: "./assets/poi_resources.png",
      unknown: "./assets/poi_unknown.png",
    };

    const TYPE_LABEL = {
      settlement: "Поселение",
      outpost: "Застава",
      ruins: "Руины/Храм",
      danger: "Опасность",
      resources: "Ресурсы",
      unknown: "Неизвестно",
    };

    const TYPE_ORDER = ["settlement", "outpost", "ruins", "danger", "resources", "unknown"];

    // ===============================
    // SUPABASE REST HELPERS
    // ===============================
    function sbHeaders() {
      return {
        "apikey": SUPABASE_ANON_KEY,
        "Authorization": "Bearer " + SUPABASE_ANON_KEY,
        "Content-Type": "application/json",
      };
    }

    async function cloudLoadPoints() {
      if (!CLOUD_ENABLED) return [];
      const url =
        `${SUPABASE_URL}/rest/v1/markers?` +
        `map_id=eq.${encodeURIComponent(MAP_ID)}` +
        `&select=id,map_id,name,notes,type,c,r,updated_at` +
        `&order=updated_at.asc`;

      const res = await fetch(url, { headers: sbHeaders() });
      if (!res.ok) throw new Error("cloudLoadPoints failed: " + res.status);
      return await res.json();
    }

    async function cloudUpsertPoint(p) {
      if (!CLOUD_ENABLED) return;

      const body = [{
        id: p.id,
        map_id: MAP_ID,
        name: p.name,
        notes: p.notes || "",
        type: p.type,
        c: p.c,
        r: p.r,
        updated_at: new Date().toISOString()
      }];

      const res = await fetch(`${SUPABASE_URL}/rest/v1/markers?on_conflict=id`, {
        method: "POST",
        headers: { ...sbHeaders(), "Prefer": "resolution=merge-duplicates,return=minimal" },
        body: JSON.stringify(body),
      });

      if (!res.ok) throw new Error("cloudUpsertPoint failed: " + res.status);
    }

    async function cloudDeletePoint(id) {
      if (!CLOUD_ENABLED) return;
      const res = await fetch(`${SUPABASE_URL}/rest/v1/markers?id=eq.${encodeURIComponent(id)}`, {
        method: "DELETE",
        headers: sbHeaders(),
      });
      if (!res.ok) throw new Error("cloudDeletePoint failed: " + res.status);
    }

    async function cloudDeleteAllForMap() {
      if (!CLOUD_ENABLED) return;
      const res = await fetch(`${SUPABASE_URL}/rest/v1/markers?map_id=eq.${encodeURIComponent(MAP_ID)}`, {
        method: "DELETE",
        headers: sbHeaders(),
      });
      if (!res.ok) throw new Error("cloudDeleteAllForMap failed: " + res.status);
    }

    // ===============================
    // DOM
    // ===============================
    const wrap = document.getElementById("wrap");
    const stage = document.getElementById("stage");
    const mapImg = document.getElementById("mapImg");
    const pinsLayer = document.getElementById("pins");

    const gridCanvas = document.getElementById("gridCanvas");
    const gctx = gridCanvas.getContext("2d");

    const measureSvg = document.getElementById("measureSvg");

    const enterGmBtn = document.getElementById("enterGmBtn");
    const exitGmBtn = document.getElementById("exitGmBtn");
    const resetBtn = document.getElementById("resetBtn");
    const resetViewBtn = document.getElementById("resetViewBtn");
    const gridBtn = document.getElementById("gridBtn");
    const measureBtn = document.getElementById("measureBtn");

    const searchInput = document.getElementById("search");
    const typeFilter = document.getElementById("typeFilter");
    const sortFilter = document.getElementById("sortFilter");
    const listEl = document.getElementById("list");
    const countBadge = document.getElementById("countBadge");

    // GM modal
    const gmBackdrop = document.getElementById("gmBackdrop");
    const gmModalTitle = document.getElementById("gmModalTitle");
    const gmClose = document.getElementById("gmClose");
    const gmCancel = document.getElementById("gmCancel");
    const gmSave = document.getElementById("gmSave");
    const nameInput = document.getElementById("nameInput");
    const notesInput = document.getElementById("notesInput");
    const typeGrid = document.getElementById("typeGrid");
    const deleteBtn = document.getElementById("deleteBtn");

    // Player view modal
    const viewBackdrop = document.getElementById("viewBackdrop");
    const viewClose = document.getElementById("viewClose");
    const viewOkBtn = document.getElementById("viewOkBtn");
    const viewCenterBtn = document.getElementById("viewCenterBtn");
    const viewIconInner = document.getElementById("viewIconInner");
    const viewName = document.getElementById("viewName");
    const viewTypeTag = document.getElementById("viewTypeTag");
    const viewNotes = document.getElementById("viewNotes");
    const viewNotesEmpty = document.getElementById("viewNotesEmpty");

    // ===============================
    // LOCAL STORAGE (only for GM toggle + optional fallback)
    // ===============================
    const STORAGE_GM = "poi_gm_enabled_v8";
    const STORAGE_FALLBACK_POINTS = "poi_points_fallback_v8"; // optional backup

    let isGm = loadIsGm();

    function loadIsGm() {
      return localStorage.getItem(STORAGE_GM) === "1";
    }
    function saveIsGm() {
      localStorage.setItem(STORAGE_GM, isGm ? "1" : "0");
    }

    // ===============================
    // APP STATE
    // ===============================
    let points = [];

    // Stage transform
    let scale = 1, tx = 0, ty = 0;

    // Pan drag
    let panning = false;
    let panStartX = 0, panStartY = 0, panStartTx = 0, panStartTy = 0;

    // Pin drag (GM)
    const pinDrag = {
      active: false,
      moved: false,
      startClientX: 0,
      startClientY: 0,
      pointId: null,
      pinEl: null,
    };
    const DRAG_THRESHOLD_PX = 4;

    // GM modal state
    let gmMode = "create"; // "create" | "edit"
    let gmSelectedType = "unknown";
    let gmTargetPointId = null;
    let gmPendingCell = null; // {c, r}

    // Player view state
    let viewPointId = null;

    // Grid state
    let gridEnabled = true;

    // Measure state
    let measureEnabled = false;
    let measureStart = null; // {c,r}

    // ===============================
    // HELPERS
    // ===============================
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function clampInt(v, min, max) { return Math.max(min, Math.min(max, v | 0)); }

    function uuidv4() {
      // RFC4122 v4
      if (crypto && crypto.randomUUID) return crypto.randomUUID();
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = [...bytes].map(b => b.toString(16).padStart(2, "0")).join("");
      return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
    }

    function updateGmButtons() {
      if (isGm) {
        enterGmBtn.style.display = "none";
        exitGmBtn.style.display = "inline-block";
        resetBtn.disabled = false;
      } else {
        enterGmBtn.style.display = "inline-block";
        exitGmBtn.style.display = "none";
        resetBtn.disabled = true;
      }
    }

    function applyStageTransform() {
      stage.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    }

    function resetView() {
      scale = 1; tx = 0; ty = 0;
      applyStageTransform();
    }

    // Screen -> Stage coords
    function screenToStage(clientX, clientY) {
      const r = wrap.getBoundingClientRect();
      const x = clientX - r.left;
      const y = clientY - r.top;
      return { sx: (x - tx) / scale, sy: (y - ty) / scale };
    }

    // Compute "contain" drawn rect in stage coords
    function getDrawnImageMetricsInStage() {
      const rectW = wrap.clientWidth;
      const rectH = wrap.clientHeight;

      const naturalW = mapImg.naturalWidth;
      const naturalH = mapImg.naturalHeight;
      if (!naturalW || !naturalH) return null;

      const imgAspect = naturalW / naturalH;
      const rectAspect = rectW / rectH;

      let drawnW, drawnH, offsetX, offsetY;

      if (rectAspect > imgAspect) {
        drawnH = rectH;
        drawnW = drawnH * imgAspect;
        offsetX = (rectW - drawnW) / 2;
        offsetY = 0;
      } else {
        drawnW = rectW;
        drawnH = drawnW / imgAspect;
        offsetX = 0;
        offsetY = (rectH - drawnH) / 2;
      }

      return { drawnW, drawnH, offsetX, offsetY };
    }

    // From stage point -> normalized (0..1) in image rect (clamped)
    function normalizedFromStagePoint(sx, sy) {
      const m = getDrawnImageMetricsInStage();
      if (!m) return null;

      const xOnImage = sx - m.offsetX;
      const yOnImage = sy - m.offsetY;

      const nx = clamp(xOnImage / m.drawnW, 0, 1);
      const ny = clamp(yOnImage / m.drawnH, 0, 1);
      return { nx, ny };
    }

    // From click -> normalized (0..1), returns null if outside image rect
    function getNormalizedPointFromClick(e) {
      const m = getDrawnImageMetricsInStage();
      if (!m) return null;

      const p = screenToStage(e.clientX, e.clientY);
      const xOnImage = p.sx - m.offsetX;
      const yOnImage = p.sy - m.offsetY;

      if (xOnImage < 0 || yOnImage < 0 || xOnImage > m.drawnW || yOnImage > m.drawnH) return null;
      return { nx: xOnImage / m.drawnW, ny: yOnImage / m.drawnH };
    }

    // Grid helpers
    function normToNearestCell(nx, ny) {
      const c = clampInt(Math.floor(nx * GRID_COLS), 0, GRID_COLS - 1);
      const r = clampInt(Math.floor(ny * GRID_ROWS), 0, GRID_ROWS - 1);
      return { c, r };
    }

    function cellCenterToNorm(c, r) {
      return {
        nx: (c + 0.5) / GRID_COLS,
        ny: (r + 0.5) / GRID_ROWS
      };
    }

    function centerOnPoint(point) {
      const m = getDrawnImageMetricsInStage();
      if (!m) return;

      const cn = cellCenterToNorm(point.c ?? 0, point.r ?? 0);
      const targetX = m.offsetX + cn.nx * m.drawnW;
      const targetY = m.offsetY + cn.ny * m.drawnH;

      const vw = wrap.clientWidth;
      const vh = wrap.clientHeight;

      tx = (vw / 2) - targetX * scale;
      ty = (vh / 2) - targetY * scale;
      applyStageTransform();
    }

    // ===============================
    // GRID RENDER
    // ===============================
    function drawGrid() {
      gridCanvas.width = wrap.clientWidth;
      gridCanvas.height = wrap.clientHeight;

      gctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
      if (!gridEnabled) return;

      const m = getDrawnImageMetricsInStage();
      if (!m) return;

      const cellW = m.drawnW / GRID_COLS;
      const cellH = m.drawnH / GRID_ROWS;

      const left = m.offsetX;
      const top = m.offsetY;

      gctx.save();
      gctx.beginPath();
      gctx.rect(left, top, m.drawnW, m.drawnH);
      gctx.clip();

      gctx.strokeStyle = "rgba(255,255,255,0.35)";
      gctx.lineWidth = 1;

      for (let i = 0; i <= GRID_COLS; i++) {
        const x = left + i * cellW;
        gctx.beginPath();
        gctx.moveTo(x, top);
        gctx.lineTo(x, top + m.drawnH);
        gctx.stroke();
      }

      for (let j = 0; j <= GRID_ROWS; j++) {
        const y = top + j * cellH;
        gctx.beginPath();
        gctx.moveTo(left, y);
        gctx.lineTo(left + m.drawnW, y);
        gctx.stroke();
      }

      gctx.restore();
    }

    // ===============================
    // MEASURE (ruler)
    // ===============================
    function cellDistance(a, b) {
  const dx = Math.abs(b.c - a.c);
  const dy = Math.abs(b.r - a.r);

  const diagonals = Math.min(dx, dy);
  const straights = Math.abs(dx - dy);

  const pairs = Math.floor(diagonals / 2);
  const remainder = diagonals % 2;

  // каждая пара диагоналей = 3 клетки (1 + 2)
  return pairs * 3 + remainder * 1 + straights;
}


    function clearMeasure() {
      measureStart = null;
      measureSvg.innerHTML = "";
    }

    function drawMeasureLine(a, b) {
      const m = getDrawnImageMetricsInStage();
      if (!m) return;

      measureSvg.setAttribute("width", wrap.clientWidth);
      measureSvg.setAttribute("height", wrap.clientHeight);

      const an = cellCenterToNorm(a.c, a.r);
      const bn = cellCenterToNorm(b.c, b.r);

      const ax = m.offsetX + an.nx * m.drawnW;
      const ay = m.offsetY + an.ny * m.drawnH;
      const bx = m.offsetX + bn.nx * m.drawnW;
      const by = m.offsetY + bn.ny * m.drawnH;

      const cells = cellDistance(a, b);
      const miles = cells * MILES_PER_CELL;

      const midx = (ax + bx) / 2;
      const midy = (ay + by) / 2;

      measureSvg.innerHTML = `
        <line x1="${ax}" y1="${ay}" x2="${bx}" y2="${by}"
              stroke="rgba(255,255,255,0.9)" stroke-width="2" />
        <circle cx="${ax}" cy="${ay}" r="4" fill="rgba(255,255,255,0.9)"/>
        <circle cx="${bx}" cy="${by}" r="4" fill="rgba(255,255,255,0.9)"/>
        <rect x="${midx - 105}" y="${midy - 18}" width="210" height="36"
              rx="12" fill="rgba(0,0,0,0.65)" stroke="rgba(255,255,255,0.15)"/>
        <text x="${midx}" y="${midy + 5}" text-anchor="middle"
              fill="white" font-size="13" font-family="system-ui">
          ${cells} клеток = ${miles} миль
        </text>
      `;
    }

    // ===============================
    // PLAYER VIEW MODAL
    // ===============================
    function openViewModal(point) {
      viewPointId = point.id;

      const label = TYPE_LABEL[point.type] || TYPE_LABEL.unknown;
      viewIconInner.style.backgroundImage = `url("${ICONS[point.type] || ICONS.unknown}")`;
      viewName.textContent = point.name || "Без названия";
      viewTypeTag.textContent = label;

      const notes = (point.notes || "").trim();
      if (notes) {
        viewNotes.textContent = notes;
        viewNotes.style.display = "block";
        viewNotesEmpty.style.display = "none";
      } else {
        viewNotes.textContent = "";
        viewNotes.style.display = "none";
        viewNotesEmpty.style.display = "block";
      }

      viewBackdrop.style.display = "flex";
    }

    function closeViewModal() {
      viewBackdrop.style.display = "none";
      viewPointId = null;
    }

    // ===============================
    // GM MODAL (create/edit)
    // ===============================
    function buildTypeGrid() {
      typeGrid.innerHTML = "";
      for (const t of TYPE_ORDER) {
        const btn = document.createElement("div");
        btn.className = "typeBtn";
        btn.dataset.type = t;

        const icon = document.createElement("div");
        icon.className = "typeIcon";
        icon.style.backgroundImage = `url("${ICONS[t]}")`;

        const label = document.createElement("div");
        label.className = "typeLabel";
        label.textContent = TYPE_LABEL[t];

        btn.appendChild(icon);
        btn.appendChild(label);

        btn.addEventListener("click", () => {
          gmSelectedType = t;
          syncTypeSelection();
        });

        typeGrid.appendChild(btn);
      }
    }

    function syncTypeSelection() {
      const nodes = typeGrid.querySelectorAll(".typeBtn");
      nodes.forEach(n => n.classList.toggle("selected", n.dataset.type === gmSelectedType));
    }

    function openGmCreateModal(cell) {
      gmMode = "create";
      gmPendingCell = cell;
      gmTargetPointId = null;

      gmModalTitle.textContent = "Новое место";
      nameInput.value = "Неизвестное место";
      notesInput.value = "";
      gmSelectedType = "unknown";
      deleteBtn.style.display = "none";
      gmSave.textContent = "Добавить";

      buildTypeGrid();
      syncTypeSelection();

      gmBackdrop.style.display = "flex";
      setTimeout(() => nameInput.focus(), 0);
    }

    function openGmEditModal(point) {
      gmMode = "edit";
      gmPendingCell = null;
      gmTargetPointId = point.id;

      gmModalTitle.textContent = "Редактировать место";
      nameInput.value = point.name || "";
      notesInput.value = point.notes || "";
      gmSelectedType = point.type || "unknown";
      deleteBtn.style.display = "inline-block";
      gmSave.textContent = "Сохранить";

      buildTypeGrid();
      syncTypeSelection();

      gmBackdrop.style.display = "flex";
      setTimeout(() => nameInput.focus(), 0);
    }

    function closeGmModal() {
      gmBackdrop.style.display = "none";
      gmMode = "create";
      gmSelectedType = "unknown";
      gmTargetPointId = null;
      gmPendingCell = null;
      nameInput.value = "";
      notesInput.value = "";
    }

    // ===============================
    // RENDER
    // ===============================
    function renderPins() {
      pinsLayer.innerHTML = "";
      const m = getDrawnImageMetricsInStage();
      if (!m) return;

      for (const p of points) {
        const el = document.createElement("div");
        el.className = "pin";
        el.dataset.id = p.id;

        const cn = cellCenterToNorm(p.c ?? 0, p.r ?? 0);
        el.style.left = (m.offsetX + cn.nx * m.drawnW) + "px";
        el.style.top  = (m.offsetY + cn.ny * m.drawnH) + "px";
        el.style.backgroundImage = `url("${ICONS[p.type] || ICONS.unknown}")`;

        const label = TYPE_LABEL[p.type] || TYPE_LABEL.unknown;
        el.title = `${p.name} — ${label}${p.notes ? " | " + p.notes : ""}`;

        // GM: drag pin or click to edit
        el.addEventListener("mousedown", (ev) => {
          ev.stopPropagation();
          if (!isGm) return;

          pinDrag.active = true;
          pinDrag.moved = false;
          pinDrag.startClientX = ev.clientX;
          pinDrag.startClientY = ev.clientY;
          pinDrag.pointId = p.id;
          pinDrag.pinEl = el;
          el.classList.add("dragging");
        });

        // Click pin
        el.addEventListener("click", (ev) => {
          ev.stopPropagation();

          // Measure mode: pin as target
          if (measureEnabled) {
            const cell = { c: p.c ?? 0, r: p.r ?? 0 };
            if (!measureStart) {
              measureStart = cell;
              drawMeasureLine(measureStart, measureStart);
            } else {
              drawMeasureLine(measureStart, cell);
            }
            return;
          }

          centerOnPoint(p);
          if (isGm) return;
          openViewModal(p);
        });

        pinsLayer.appendChild(el);
      }
    }

    function getFilteredPoints() {
      const q = (searchInput.value || "").trim().toLowerCase();
      const t = typeFilter.value;
      const sortMode = sortFilter.value;

      let arr = points.slice();
      if (q) {
        arr = arr.filter(p =>
          (p.name || "").toLowerCase().includes(q) ||
          (p.notes || "").toLowerCase().includes(q)
        );
      }
      if (t !== "all") arr = arr.filter(p => p.type === t);

      if (sortMode === "name") {
        arr.sort((a, b) => (a.name || "").localeCompare(b.name || "", "ru"));
      } else {
        arr.sort((a, b) => {
          const ta = TYPE_ORDER.indexOf(a.type);
          const tb = TYPE_ORDER.indexOf(b.type);
          if (ta !== tb) return ta - tb;
          return (a.name || "").localeCompare(b.name || "", "ru");
        });
      }
      return arr;
    }

    function renderList() {
      const filtered = getFilteredPoints();
      listEl.innerHTML = "";
      countBadge.textContent = `${filtered.length} / ${points.length}`;

      for (const p of filtered) {
        const row = document.createElement("div");
        row.className = "item";

        const name = document.createElement("div");
        name.className = "itemName";
        name.textContent = p.name || "Без названия";

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = TYPE_LABEL[p.type] || TYPE_LABEL.unknown;

        row.appendChild(name);
        row.appendChild(tag);

        row.addEventListener("click", () => {
          // Measure: list item as target too
          if (measureEnabled) {
            const cell = { c: p.c ?? 0, r: p.r ?? 0 };
            if (!measureStart) {
              measureStart = cell;
              drawMeasureLine(measureStart, measureStart);
            } else {
              drawMeasureLine(measureStart, cell);
            }
            return;
          }

          centerOnPoint(p);
          if (isGm) openGmEditModal(p);
          else openViewModal(p);
        });

        listEl.appendChild(row);
      }
    }

    function renderAll() {
      renderPins();
      renderList();
      updateGmButtons();
      drawGrid();
    }

    function saveFallbackToLocal() {
      try {
        localStorage.setItem(STORAGE_FALLBACK_POINTS, JSON.stringify(points));
      } catch {}
    }

    // ===============================
    // EVENTS
    // ===============================

    // Zoom to cursor (ignore wheel over UI/panel/modals)
    wrap.addEventListener("wheel", (e) => {
      if (e.target.closest("#panel") || e.target.closest("#ui") || e.target.closest(".modal")) return;
      e.preventDefault();

      const before = screenToStage(e.clientX, e.clientY);
      const factor = Math.exp(-e.deltaY * ZOOM_SENSITIVITY);
      const newScale = clamp(scale * factor, MIN_SCALE, MAX_SCALE);
      if (newScale === scale) return;

      scale = newScale;

      const r = wrap.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;

      tx = x - before.sx * scale;
      ty = y - before.sy * scale;
      applyStageTransform();
    }, { passive: false });

    // Pan with drag (only when not dragging a pin)
    wrap.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      if (e.target.closest("#panel") || e.target.closest("#ui") || e.target.closest(".modal")) return;
      if (pinDrag.active) return;
      if (e.target.classList.contains("pin")) return;

      panning = true;
      stage.classList.add("dragging");
      panStartX = e.clientX;
      panStartY = e.clientY;
      panStartTx = tx;
      panStartTy = ty;
    });

    // Drag move
    window.addEventListener("mousemove", (e) => {
      // Pin dragging (GM)
      if (pinDrag.active && isGm) {
        const dx = e.clientX - pinDrag.startClientX;
        const dy = e.clientY - pinDrag.startClientY;
        if (!pinDrag.moved && (Math.abs(dx) > DRAG_THRESHOLD_PX || Math.abs(dy) > DRAG_THRESHOLD_PX)) {
          pinDrag.moved = true;
        }

        const point = points.find(x => x.id === pinDrag.pointId);
        if (!point) return;

        const sp = screenToStage(e.clientX, e.clientY);
        const norm = normalizedFromStagePoint(sp.sx, sp.sy);
        if (!norm) return;

        const cell = normToNearestCell(norm.nx, norm.ny);
        point.c = cell.c;
        point.r = cell.r;

        renderPins();
        return;
      }

      // Stage panning
      if (!panning) return;
      tx = panStartTx + (e.clientX - panStartX);
      ty = panStartTy + (e.clientY - panStartY);
      applyStageTransform();
    });

    // Mouse up
    window.addEventListener("mouseup", async () => {
      // End pin drag
      if (pinDrag.active && isGm) {
        const point = points.find(x => x.id === pinDrag.pointId);
        if (pinDrag.pinEl) pinDrag.pinEl.classList.remove("dragging");

        const wasMoved = pinDrag.moved;

        pinDrag.active = false;
        pinDrag.moved = false;
        pinDrag.pointId = null;
        pinDrag.pinEl = null;

        if (!point) return;

        if (wasMoved) {
          try { await cloudUpsertPoint(point); } catch (e) { console.error(e); }
          saveFallbackToLocal();
          renderAll();
        } else {
          openGmEditModal(point);
        }
        return;
      }

      // End pan
      panning = false;
      stage.classList.remove("dragging");
    });

    // Add point on DOUBLE CLICK (GM only) — snapped to nearest cell
    wrap.addEventListener("dblclick", (e) => {
      if (!isGm) return;
      if (e.target.closest("#panel") || e.target.closest("#ui") || e.target.closest(".modal")) return;
      if (e.target.classList.contains("pin")) return;
      if (pinDrag.active) return;

      const norm = getNormalizedPointFromClick(e);
      if (!norm) return;

      const cell = normToNearestCell(norm.nx, norm.ny);
      openGmCreateModal(cell);
    });

    // Measure: click on empty map (cell)
    wrap.addEventListener("click", (e) => {
      if (!measureEnabled) return;
      if (e.target.closest("#panel") || e.target.closest("#ui") || e.target.closest(".modal")) return;
      if (e.target.classList.contains("pin")) return;

      const norm = getNormalizedPointFromClick(e);
      if (!norm) return;

      const cell = normToNearestCell(norm.nx, norm.ny);

      if (!measureStart) {
        measureStart = cell;
        drawMeasureLine(measureStart, measureStart);
      } else {
        drawMeasureLine(measureStart, cell);
      }
    });

    // GM enter/exit
    enterGmBtn.addEventListener("click", () => {
      const input = prompt("Введите пароль GM:");
      if (input === null) return;

      if (input === GM_PASSWORD) {
        isGm = true;
        saveIsGm();
        updateGmButtons();
      } else {
        alert("Неверный пароль.");
      }
    });

    exitGmBtn.addEventListener("click", () => {
      isGm = false;
      saveIsGm();
      updateGmButtons();
      closeGmModal();
    });

    // Reset points (cloud)
    resetBtn.addEventListener("click", async () => {
      if (!isGm) return;
      const ok = confirm("Удалить ВСЕ точки? Это нельзя отменить.");
      if (!ok) return;

      try { await cloudDeleteAllForMap(); } catch (e) { console.error(e); }
      points = [];
      saveFallbackToLocal();
      renderAll();
    });

    // Reset view
    resetViewBtn.addEventListener("click", () => {
      resetView();
    });

    // Toggle grid
    gridBtn.addEventListener("click", () => {
      gridEnabled = !gridEnabled;
      gridCanvas.style.display = gridEnabled ? "block" : "none";
      if (gridEnabled) drawGrid();
      gridBtn.style.background = gridEnabled ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.10)";
    });

    // Toggle measure
    measureBtn.addEventListener("click", () => {
      measureEnabled = !measureEnabled;
      if (!measureEnabled) clearMeasure();
      measureBtn.style.background = measureEnabled ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.10)";
    });

    // Panel controls
    searchInput.addEventListener("input", renderList);
    typeFilter.addEventListener("change", renderList);
    sortFilter.addEventListener("change", renderList);

    // GM modal controls
    gmClose.addEventListener("click", closeGmModal);
    gmCancel.addEventListener("click", closeGmModal);

    gmBackdrop.addEventListener("click", (e) => {
      if (e.target === gmBackdrop) closeGmModal();
    });

    deleteBtn.addEventListener("click", async () => {
      if (!isGm) return;
      if (!gmTargetPointId) return;

      const ok = confirm("Удалить эту точку?");
      if (!ok) return;

      const id = gmTargetPointId;

      points = points.filter(p => p.id !== id);
      closeGmModal();
      renderAll();

      try { await cloudDeletePoint(id); } catch (e) { console.error(e); }
      saveFallbackToLocal();
    });

    gmSave.addEventListener("click", async () => {
      if (!isGm) return;

      const name = (nameInput.value || "").trim() || "Неизвестное место";
      const notes = (notesInput.value || "").trim();
      const type = gmSelectedType || "unknown";

      if (gmMode === "create") {
        if (!gmPendingCell) return;

        const p = {
          id: uuidv4(),
          map_id: MAP_ID,
          name,
          notes,
          type,
          c: gmPendingCell.c,
          r: gmPendingCell.r,
          updated_at: new Date().toISOString()
        };

        points.push(p);
        closeGmModal();
        renderAll();

        try { await cloudUpsertPoint(p); } catch (e) { console.error(e); }
        saveFallbackToLocal();
        return;
      }

      if (gmMode === "edit") {
        const p = points.find(x => x.id === gmTargetPointId);
        if (!p) return;

        p.name = name;
        p.notes = notes;
        p.type = type;
        p.updated_at = new Date().toISOString();

        closeGmModal();
        renderAll();

        try { await cloudUpsertPoint(p); } catch (e) { console.error(e); }
        saveFallbackToLocal();
      }
    });

    // Player view modal controls
    viewClose.addEventListener("click", closeViewModal);
    viewOkBtn.addEventListener("click", closeViewModal);

    viewCenterBtn.addEventListener("click", () => {
      if (!viewPointId) return;
      const p = points.find(x => x.id === viewPointId);
      if (!p) return;
      centerOnPoint(p);
    });

    viewBackdrop.addEventListener("click", (e) => {
      if (e.target === viewBackdrop) closeViewModal();
    });

    // Keyboard: ESC closes any open modal; Enter saves in GM modal
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (gmBackdrop.style.display === "flex") closeGmModal();
        if (viewBackdrop.style.display === "flex") closeViewModal();
        if (measureEnabled) { measureEnabled = false; clearMeasure(); measureBtn.style.background = "rgba(255,255,255,0.10)"; }
      }
      if (e.key === "Enter" && gmBackdrop.style.display === "flex") {
        const active = document.activeElement;
        if (active && active.id === "notesInput") return;
        gmSave.click();
      }
    });

    // ===============================
    // CLOUD SYNC LOOP (players)
    // ===============================
    let lastCloudStamp = 0;

    function computeStamp(arr) {
      // max updated_at
      let max = 0;
      for (const p of arr) {
        const t = Date.parse(p.updated_at || "") || 0;
        if (t > max) max = t;
      }
      return max;
    }

    async function refreshFromCloud() {
      try {
        const fresh = await cloudLoadPoints();
        const stamp = computeStamp(fresh);

        // Avoid re-render if nothing changed
        if (stamp === lastCloudStamp && fresh.length === points.length) return;

        points = fresh.map(p => ({
          id: p.id,
          name: p.name || "",
          notes: p.notes || "",
          type: p.type || "unknown",
          c: typeof p.c === "number" ? p.c : 0,
          r: typeof p.r === "number" ? p.r : 0,
          updated_at: p.updated_at || null
        }));
        lastCloudStamp = stamp;
        renderAll();
        saveFallbackToLocal();
      } catch (e) {
        console.error(e);
      }
    }

    // ===============================
    // INIT
    // ===============================
    buildTypeGrid();
    syncTypeSelection();

    mapImg.addEventListener("load", () => {
      renderAll();
      applyStageTransform();
      drawGrid();
    });

    window.addEventListener("resize", () => {
      renderAll();
      drawGrid();
    });

    updateGmButtons();
    gridBtn.style.background = "rgba(255,255,255,0.18)";
    measureBtn.style.background = "rgba(255,255,255,0.10)";

    // Initial load from cloud
    (async () => {
      // Try cloud first
      await refreshFromCloud();

      // Fallback: if cloud empty, try local backup so you at least see something
      if (points.length === 0) {
        try {
          const raw = localStorage.getItem(STORAGE_FALLBACK_POINTS);
          const arr = raw ? JSON.parse(raw) : [];
          if (Array.isArray(arr) && arr.length) {
            points = arr;
            renderAll();
          }
        } catch {}
      }

      // Players auto refresh
      setInterval(async () => {
        if (!CLOUD_ENABLED) return;
        if (isGm) return; // GM не перетираем авто-рефрешем
        if (gmBackdrop.style.display === "flex") return;
        await refreshFromCloud();
      }, 5000);
    })();

    renderAll();
    applyStageTransform();
    drawGrid();
  </script>
</body>
</html>

